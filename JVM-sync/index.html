<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">
  
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>JVM Thread와 동기화 | 서영원 블로그</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="JVM Thread와 동기화" />
<meta name="author" content="Youngwon Seo" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1. 자바에서의 동기화 자바는 멀티쓰레딩을 지원합니다(정확하게 JVM이). 그리고 각 쓰레드를 동기화 하기 위해 Monitor를 사용합니다. 여기거 동기화란 여러 쓰레드가 동시에 한 메모리영역에 접근시 데이터의 무결정을 위해 락을 걸어 동시에 한 쓰레드만 접근가능하게 하는 것입니다. 자바는 동기화를 위해 문법적으로 synchronized를 이용하며 실제로는 Monitor의 메커니즘을 사용합니다. 정확하게 설명하면 Critical Section(여러쓰레드가 동시에 접근할려고 하는 구간)에 특정 쓰레드가 접근할 시 Lock 에대한 Object Monitor를 1증가시켜 해당 구간을 실행하고 빠져나오면 다시 1증가 시켰던 Monitor를 -1하여 다른 쓰레드가 접근가능하도록 만듭니다. 이를 위해 자바는 문법적으로 synchronized를 실행하는 것이죠. (멀티쓰레딩과 동기화 부분의 이론적 내용을 자세히 알고싶으신 분은 운영체제를 공부하시는 것을 추천합니다) 이렇게 쓰레드에 대한 동기화를 위해 각 쓰레드는 상태를 변경하며 프로그램이 실행되는데 이는 두 번째 절인 Thread의 상태 및 종류에서 살펴봅니다." />
<meta property="og:description" content="1. 자바에서의 동기화 자바는 멀티쓰레딩을 지원합니다(정확하게 JVM이). 그리고 각 쓰레드를 동기화 하기 위해 Monitor를 사용합니다. 여기거 동기화란 여러 쓰레드가 동시에 한 메모리영역에 접근시 데이터의 무결정을 위해 락을 걸어 동시에 한 쓰레드만 접근가능하게 하는 것입니다. 자바는 동기화를 위해 문법적으로 synchronized를 이용하며 실제로는 Monitor의 메커니즘을 사용합니다. 정확하게 설명하면 Critical Section(여러쓰레드가 동시에 접근할려고 하는 구간)에 특정 쓰레드가 접근할 시 Lock 에대한 Object Monitor를 1증가시켜 해당 구간을 실행하고 빠져나오면 다시 1증가 시켰던 Monitor를 -1하여 다른 쓰레드가 접근가능하도록 만듭니다. 이를 위해 자바는 문법적으로 synchronized를 실행하는 것이죠. (멀티쓰레딩과 동기화 부분의 이론적 내용을 자세히 알고싶으신 분은 운영체제를 공부하시는 것을 추천합니다) 이렇게 쓰레드에 대한 동기화를 위해 각 쓰레드는 상태를 변경하며 프로그램이 실행되는데 이는 두 번째 절인 Thread의 상태 및 종류에서 살펴봅니다." />
<link rel="canonical" href="https://youngwonseo.github.io/JVM-sync/" />
<meta property="og:url" content="https://youngwonseo.github.io/JVM-sync/" />
<meta property="og:site_name" content="서영원 블로그" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-11T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="JVM Thread와 동기화" />
<script type="application/ld+json">
{"url":"https://youngwonseo.github.io/JVM-sync/","author":{"@type":"Person","name":"Youngwon Seo"},"headline":"JVM Thread와 동기화","dateModified":"2018-08-11T00:00:00+09:00","datePublished":"2018-08-11T00:00:00+09:00","description":"1. 자바에서의 동기화 자바는 멀티쓰레딩을 지원합니다(정확하게 JVM이). 그리고 각 쓰레드를 동기화 하기 위해 Monitor를 사용합니다. 여기거 동기화란 여러 쓰레드가 동시에 한 메모리영역에 접근시 데이터의 무결정을 위해 락을 걸어 동시에 한 쓰레드만 접근가능하게 하는 것입니다. 자바는 동기화를 위해 문법적으로 synchronized를 이용하며 실제로는 Monitor의 메커니즘을 사용합니다. 정확하게 설명하면 Critical Section(여러쓰레드가 동시에 접근할려고 하는 구간)에 특정 쓰레드가 접근할 시 Lock 에대한 Object Monitor를 1증가시켜 해당 구간을 실행하고 빠져나오면 다시 1증가 시켰던 Monitor를 -1하여 다른 쓰레드가 접근가능하도록 만듭니다. 이를 위해 자바는 문법적으로 synchronized를 실행하는 것이죠. (멀티쓰레딩과 동기화 부분의 이론적 내용을 자세히 알고싶으신 분은 운영체제를 공부하시는 것을 추천합니다) 이렇게 쓰레드에 대한 동기화를 위해 각 쓰레드는 상태를 변경하며 프로그램이 실행되는데 이는 두 번째 절인 Thread의 상태 및 종류에서 살펴봅니다.","mainEntityOfPage":{"@type":"WebPage","@id":"https://youngwonseo.github.io/JVM-sync/"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  
  
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://youngwonseo.github.io/JVM-sync/">
  <link rel="alternate" type="application/atom+xml" title="서영원 블로그" href="https://youngwonseo.github.io/feed.xml" />  
  <link rel="stylesheet" href="/assets/css/syntax.css">
</head>

  <body>
    

<div class="header-container" id="header-container">

<!-- Site navigation -->
  <nav class="site-nav">
    <div class="trigger">
      
        
        <a class="page-link" href="/about/">About</a>
        
      
        
        <a class="page-link" href="/archive/">Archive</a>
        
      
        
      
        
      
        
      
        
        <a class="page-link" href="/category/">Paper</a>
        
      
        
        <a class="page-link" href="/projects/">Projects</a>
        
      
        
        <a class="page-link" href="/study/">Study</a>
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
      <a class="page-link" href="/feed.xml">RSS</a>
    </div>
  </nav>

  <!-- The title of the site -->
  <header class="site-header">
    <!-- <a href="/">
      <div class="avatar">
        <img src="/assets/images/avatar.png" />
      </div>
    </a> -->
    <a class="site-title" href="/">서영원 블로그</a>
  </header>

</div>

      <div class="wrapper">
        <div class="page-content">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">JVM Thread와 동기화</h1>
    <p class="post-meta">2018-08-11 / Youngwon Seo</p>
  </header>



  <article class="post-content">
    <h2 id="1-자바에서의-동기화">1. 자바에서의 동기화</h2>
<p>자바는 멀티쓰레딩을 지원합니다(정확하게 JVM이). 그리고 각 쓰레드를 동기화 하기 위해 Monitor를 사용합니다. 여기거 동기화란 여러 쓰레드가 동시에 한 메모리영역에 접근시 데이터의 무결정을 위해 락을 걸어 동시에 한 쓰레드만 접근가능하게 하는 것입니다. 자바는 동기화를 위해 문법적으로 synchronized를 이용하며 실제로는 Monitor의 메커니즘을 사용합니다. 정확하게 설명하면 Critical Section(여러쓰레드가 동시에 접근할려고 하는 구간)에 특정 쓰레드가 접근할 시 Lock 에대한 Object Monitor를 1증가시켜 해당 구간을 실행하고 빠져나오면 다시 1증가 시켰던 Monitor를 -1하여 다른 쓰레드가 접근가능하도록 만듭니다. 이를 위해 자바는 문법적으로 synchronized를 실행하는 것이죠. (멀티쓰레딩과 동기화 부분의 이론적 내용을 자세히 알고싶으신 분은 운영체제를 공부하시는 것을 추천합니다)
이렇게 쓰레드에 대한 동기화를 위해 각 쓰레드는 상태를  변경하며 프로그램이 실행되는데 이는 두 번째 절인 Thread의 상태 및 종류에서 살펴봅니다.</p>

<h2 id="2-thread-상태-및-종류">2. Thread 상태 및 종류</h2>
<h3 id="21-thread-상태">2.1 Thread 상태</h3>
<p>다음은 JVM에서의 Thread들 가지는 상태들이다. 여러가지 예외 발생(성능저하 또는 메모리관련, 데드락 등) 시 Thread Dump 분석을 통해서 해결해야 하는데 이때 다음과 같은 Thread 상태들을 정확히 이해하고 있어야 한다.</p>
<ul>
  <li>NEW - Thread가 생성되어있지만 아직 실행되지 않은 상태</li>
  <li>RUNNABLE - 현재 CPU를 점유하고 작업을 수행중인 상태, 운영체제의 자원 분배로 인해 WAITING상태가 될 수 있다.</li>
  <li>BLOCKED - Monitor를 획득하기 위해 다른 Thread가 Lock을 해제하기를 기다리는 상태</li>
  <li>WAITING - wait(), join(),park() 등의 메서드를 이용해 대기하고 있는 상태</li>
  <li>TIMED_WAITING - sleep(), wait(), join(), park() 등의 메서드를 이용해 대기하고 있는 상태, WAITING 상태와의 차이점은 메서드의 인수로 최대 대기 시간을 명시할 수 있어 외부 변화뿐만 아니라 시간에 의해 WAITING 상태가 해제될 수 있다.</li>
</ul>

<p><img src="https://qph.ec.quoracdn.net/main-qimg-bb9b26ebdf42c3f502f1a6318664e04e" alt="" /></p>
<h3 id="22-thread-종류">2.2 Thread 종류</h3>
<p>JVM Thread는 데몬(Daemon) 또는 비 데몬(Non-daemon) Thread로 나뉜다. 데몬 Thread 는 비 데몬 Thread가 존재하지 않으면 자동으로  은 JVM에 의해, 비 데몬은 사용자에 의해 생선되는 Thread이다. 예로 들면 GC는 데몬,</p>
<ul>
  <li>VM-Background Thread - compile, optimization, GC 등 JVM 내부의 일을 수행하는  Background Thread등</li>
  <li>Main Thread Thread - main메서드를 실행하는 Thread, 사용자가 명시적으로 실행하지 않더라도 JVM이 실행</li>
  <li>User Thread Thread - 사용자에 의해 명시적으로 생성된 Thread들,  Thread 클래스 상속, Runnable 인터페이스 구현 등으로 생성</li>
</ul>

<h2 id="3-thread-dump">3. Thread Dump</h2>
<p>Thread Dump를 통해 Java에서 발생하는 여러가지 문제를 분석할 수 있습니다. Thread Dump를 가져오기 위해서는 플렛폼별 지원하는 커멘드를 사용하여 가져올 수 있지만 여기서는 여러 플렛폼에서 공통으로 사용가능한 Jstack을 사용하여 dump를 간단히 살펴보겠습니다. 상세정보는 References에 명시된 책이나 웹사이트를 방문해서 살펴봐주세요.
다음은 책에서 Case1으로 소개된 synchroinized에 의한 동기화의 소스코드입니다.</p>

<p>DumpText.java</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DumpTest</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="nc">Object</span> <span class="nc">Lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">new</span> <span class="nf">Thread2</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
		<span class="o">}</span><span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>			
		<span class="o">}</span>
		<span class="k">new</span> <span class="nf">Thread1</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>
		<span class="k">new</span> <span class="nf">Thread1</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>
		<span class="k">new</span> <span class="nf">Thread1</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>
	<span class="o">}</span>	
<span class="o">}</span>	
</code></pre></div></div>

<p>Thread1.java</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Thread1</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>	
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
			<span class="kd">synchronized</span><span class="o">(</span><span class="nc">DumpTest</span><span class="o">.</span><span class="na">Lock</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">idx</span><span class="o">++</span> <span class="o">+</span> <span class="s">" looping"</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>	
<span class="o">}</span>
</code></pre></div></div>

<p>Thread2.java</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Thread2</span> <span class="kd">extends</span> <span class="nc">Thread</span><span class="o">{</span>	
	<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
			<span class="kd">synchronized</span><span class="o">(</span><span class="nc">DumpTest</span><span class="o">.</span><span class="na">Lock</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">idx</span><span class="o">++</span> <span class="o">+</span> <span class="s">" looping"</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>	
<span class="o">}</span>
</code></pre></div></div>
<p>Thread1과 Thread2는 같은 코드입니다.  여기서 각 Thread에 대한 run에서 synchronized를 통해 동기화를 하는데 DumpTest 클레스에 속한 Lock오브젝트를 monitor를 사용합니다.</p>

<p>저는 윈도우즈 환경에서 Jstack을 통해  dump를 얻었고 내용은 다음과 같습니다(jstack 사용법 - $ jstack [PID]).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.144-b01 mixed mode):

"DestroyJavaVM" #14 prio=5 os_prio=0 tid=0x0000000002dce800 nid=0x3ec0 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Thread-3" #13 prio=5 os_prio=0 tid=0x0000000026f82000 nid=0x2bb8 runnable [0x0000000027d1e000]
   java.lang.Thread.State: RUNNABLE
        at java.io.FileOutputStream.writeBytes(Native Method)
        at java.io.FileOutputStream.write(Unknown Source)
        at java.io.BufferedOutputStream.flushBuffer(Unknown Source)
        at java.io.BufferedOutputStream.flush(Unknown Source)
        - locked &lt;0x00000005c1412e58&gt; (a java.io.BufferedOutputStream)
        at java.io.PrintStream.write(Unknown Source)
        - locked &lt;0x00000005c1404728&gt; (a java.io.PrintStream)
        at sun.nio.cs.StreamEncoder.writeBytes(Unknown Source)
        at sun.nio.cs.StreamEncoder.implFlushBuffer(Unknown Source)
        at sun.nio.cs.StreamEncoder.flushBuffer(Unknown Source)
        - locked &lt;0x00000005c1412f80&gt; (a java.io.OutputStreamWriter)
        at java.io.OutputStreamWriter.flushBuffer(Unknown Source)
        at java.io.PrintStream.write(Unknown Source)
        - eliminated &lt;0x00000005c1404728&gt; (a java.io.PrintStream)
        at java.io.PrintStream.print(Unknown Source)
        at java.io.PrintStream.println(Unknown Source)
        - locked &lt;0x00000005c1404728&gt; (a java.io.PrintStream)
        at Thread1.run(Thread1.java:10)
        - locked &lt;0x00000005c1406378&gt; (a java.lang.Object)

"Thread-2" #12 prio=5 os_prio=0 tid=0x0000000026f81800 nid=0xa48 waiting for monitor entry [0x0000000027c1f000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at Thread1.run(Thread1.java:9)
        - waiting to lock &lt;0x00000005c1406378&gt; (a java.lang.Object)

"Thread-1" #11 prio=5 os_prio=0 tid=0x0000000026f7f800 nid=0x3ff4 waiting for monitor entry [0x0000000027b1e000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at Thread1.run(Thread1.java:9)
        - waiting to lock &lt;0x00000005c1406378&gt; (a java.lang.Object)

"Thread-0" #10 prio=5 os_prio=0 tid=0x0000000026f1e000 nid=0x3414 waiting for monitor entry [0x0000000027a1f000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at Thread2.run(Thread2.java:9)
        - waiting to lock &lt;0x00000005c1406378&gt; (a java.lang.Object)

"Service Thread" #9 daemon prio=9 os_prio=0 tid=0x0000000025a9d000 nid=0x389c runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C1 CompilerThread2" #8 daemon prio=9 os_prio=2 tid=0x0000000025a62000 nid=0x2a2c waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread1" #7 daemon prio=9 os_prio=2 tid=0x0000000025a5f000 nid=0x348c waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"C2 CompilerThread0" #6 daemon prio=9 os_prio=2 tid=0x0000000025a50000 nid=0x248 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x0000000025a4e000 nid=0x24e4 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x0000000026e62800 nid=0x37b8 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x0000000025a2a800 nid=0x3c70 in Object.wait() [0x0000000026d9f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on &lt;0x00000005c1406ae8&gt; (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(Unknown Source)
        - locked &lt;0x00000005c1406ae8&gt; (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(Unknown Source)
        at java.lang.ref.Finalizer$FinalizerThread.run(Unknown Source)

"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x0000000002ec1800 nid=0x3d54 in Object.wait() [0x0000000026c9f000]
   java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on &lt;0x00000005c1408b40&gt; (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Unknown Source)
        at java.lang.ref.Reference.tryHandlePending(Unknown Source)
        - locked &lt;0x00000005c1408b40&gt; (a java.lang.ref.Reference$Lock)
        at java.lang.ref.Reference$ReferenceHandler.run(Unknown Source)

"VM Thread" os_prio=2 tid=0x0000000025a07800 nid=0x3144 runnable

"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x0000000002de7800 nid=0x2290 runnable

"GC task thread#1 (ParallelGC)" os_prio=0 tid=0x0000000002de9000 nid=0x27d4 runnable

"GC task thread#2 (ParallelGC)" os_prio=0 tid=0x0000000002dea800 nid=0x1cd0 runnable

"GC task thread#3 (ParallelGC)" os_prio=0 tid=0x0000000002ded000 nid=0x548 runnable

"VM Periodic Task Thread" os_prio=2 tid=0x0000000026f09800 nid=0x2db0 waiting on condition

JNI global references: 14
</code></pre></div></div>
<p>먼저 Thread-0, Thread-1, Thread-2, Thread-3 나타난 것을 볼 수 있다. 4개의 Thread를 생성하였기 때문이다. 각 Thread는 tid라는 고유 아이디를 가지고 있고 상태(RUNNABLE, BLOCKED, WAITING)를 가지고 있다. 위 코드에서 살펴본것과 같이 동기화를 위해 DumpTest.Lock 오브젝트의 모니터를 사용하고 있는데 waiting for monitor entry이라는 문구가 특정 모니터 점유를 대기하고 있다는 의미이고 BLOCKED 상태의 dump를 살펴보면 Lock(해시값 : 0x00000005c1406378)의 점유를 위해 대기하고 있는 것을 알수있다.</p>

<h2 id="references">References</h2>
<ul>
  <li>JVM Performance Optimizing 및 성능분석 사례</li>
  <li>https://www.quora.com/What-is-a-thread-state</li>
</ul>

  </article>

  <hr>

  <!-- <div class="question">
    <h2>Questions?</h2>
    <p>Have a question regarding the post above? <br />Or any of my designs?</p>
    

  </div> -->

  <!-- <div class="related">
    <h2>Related</h2>
    
      <li><a href="/projects/auction-market/" title="경매 서비스">경매 서비스
       &nbsp; <span class="post-meta">March 29, 2021</span></a>
    
      <li><a href="/kubernetes/ingress/" title="쿠버네티스 - 인그레스(Ingress)">쿠버네티스 - 인그레스(Ingress)
       &nbsp; <span class="post-meta">February 19, 2021</span></a>
    
      <li><a href="/kubernetes/service/" title="쿠버네티스 - 서비스(Service)">쿠버네티스 - 서비스(Service)
       &nbsp; <span class="post-meta">February 18, 2021</span></a>
    
  </div> -->

  
  
    <script src="https://utteranc.es/client.js"
      repo="youngwonseo/youngwonseo.github.io"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  

</div>

        </div>
        <footer class="site-footer">
<p class="small"></p>
</footer>

    </div>

    <script src="//cdn.jsdelivr.net/headroomjs/0.5.0/headroom.min.js"></script>
    <script type="text/javascript">
      var el = document.querySelector(".header-container");
      var headroom  = new Headroom(el, {
        "offset": 205,
        "tolerance": 5
      });
      headroom.init();
    </script>


    <!-- Twitter Shizzle -->
    <script type="text/javascript">
    window.twttr = (function (d, s, id) {
      var t, js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src= "https://platform.twitter.com/widgets.js";
      fjs.parentNode.insertBefore(js, fjs);
      return window.twttr || (t = { _e: [], ready: function (f) { t._e.push(f) } });
    }(document, "script", "twitter-wjs"));
    </script>

  </body>
</html>
