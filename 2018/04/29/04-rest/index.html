<h2 id="rest">REST</h2>
<ul>
  <li>REST(Representational State Transfer)는 로이필딩(Roy Fielding)에 의해 웹의 장점을 최대한 활용할 수 있는 아키텍처로 처음 소개됬다.</li>
  <li>많은 OPEN API들이 REST기반에서 JSON을 이용한 형태로 제공되고 있다. 그만큼 신뢰를 받고있는 아키텍처이다.</li>
  <li>리소스 지향 아키텍처이다.</li>
</ul>

<h4 id="1-http메서드">1. HTTP메서드</h4>
<ul>
  <li>
    <p>REST에서는 HTTP메서드를 통해 수행할 작업이 구분된다. 아래는 CRUD에 대한 작업과 HTTP메서드의 관계이다.</p>

    <table>
      <thead>
        <tr>
          <th>Method</th>
          <th>Meaning</th>
          <th>Idempotent</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>POST</td>
          <td>Create</td>
          <td>No</td>
        </tr>
        <tr>
          <td>GET</td>
          <td>Select</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>PUT</td>
          <td>Update</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>DELETE</td>
          <td>Delete</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>가장 우측 Idempotent는 여러번 수행시 데이터의 변경 여부를 나타낸다.</li>
  <li>POST연산은 데이터를 추가하므로 Idempotent하지않지만 나머지의 경우 계속 실행해도 결과가 같다.</li>
</ul>

<h4 id="2-rest의-리소스">2. REST의 리소스</h4>
<ul>
  <li>REST는 리소스 지향 아키텍처이다.</li>
  <li>모든 리소스는 명사로 표현한다.</li>
  <li>즉, 사용자라는 리소스를 http://myweb/users 로 표현하였다면 gildong이라는 아이디의 리소스는  http://myweb/users/gildong  이라는 형태로 정의한다.</li>
</ul>

<h4 id="3-rest-예제">3. REST 예제</h4>
<ul>
  <li>REST에 대한 예제를 살펴보자</li>
  <li>내용은 HTTP BODY에 추가해서 해당 URL에 해당 METHOD로 요청(request)하는것이 핵심이다.</li>
</ul>

<h5 id="사용자-생성">사용자 생성</h5>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP POST, http://myweb/users/
{
	"name":"gildong",
	"address":"busan",
	"gender":"male"
}
</code></pre></div></div>
<ul>
  <li>POST와 사용자를 나타내는 리소스에 생성할 데이터를 JSON형식으로 Body에 포함시켜 요청한다.</li>
  <li>성공여부를 true, false 또는 error message 등을 이용하여 받을 수 있다.</li>
</ul>

<h5 id="사용자-조회">사용자 조회</h5>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP GET, http://myweb/users/
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP GET, http://myweb/users/gildong
</code></pre></div></div>
<ul>
  <li>처음 예제는 전체목록에 해당하고 두번째 예제는 gildong의 정보를 요청한다.</li>
  <li>GET으로 요청하고 있고 Body에는 아무 내용을 포함시키지 않았다.</li>
</ul>

<h5 id="사용자-업데이트">사용자 업데이트</h5>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP PUT, http://myweb/users/gildong
{
	"address":"daegu",
	"gender":"female"
}
</code></pre></div></div>
<ul>
  <li>gildong의 리소스에 대하 성별을 Body에 포함시켜 PUT으로 요청한다.</li>
</ul>

<h5 id="사용자-삭제">사용자 삭제</h5>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP DELETE, http://myweb/users/gildong
</code></pre></div></div>
<ul>
  <li>삭제를 위해 DELETE에 요청한다. 물론 아래와 같이 요청하면 users에 대한 전체 목록이 삭제된다.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP DELETE, http://myweb/users/
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="4-rest-특성">4. REST 특성</h4>
<ul>
  <li>조금 더 상세한 내용을 알아보자.</li>
</ul>

<h5 id="유니폼-인터페이스uniform-interface">유니폼 인터페이스(Uniform Interface)</h5>
<ul>
  <li>플랫폼에 상관없이 동일한 인터페이스를 제공함으로써 클라이언트가 쉽게 사용 가능하다.</li>
  <li>프론트앤드의 기술에 상관없이 백앤드를 REST로 구현하여 비즈니스 로직을 통일할수있단.</li>
</ul>

<h5 id="무상태스테이트리스-stateless">무상태/스테이트리스 (Stateless)</h5>
<ul>
  <li>세션같은 클라이언트의 상태를 기억하지 않는다.</li>
  <li>인증 같은 부분은 토큰등의 API KEY를 발급하여 관리한다.</li>
</ul>

<h5 id="캐시-가능cacheable">캐시 가능(Cacheable)</h5>
<ul>
  <li>HTTP에서 제공하는 장점인 캐시, 로드벨런스 등을 그래로 사용할 수 있다.</li>
</ul>

<h5 id="자체-표현-구조self-descriptiveness">자체 표현 구조(Self-descriptiveness)</h5>
<ul>
  <li>리소스의 경로와 정해진 Method를 보고 API해석이 가능하다.</li>
  <li>최소한의 문서로 쉽게 사용가능하다.</li>
</ul>

<h5 id="클라이언트-서버-구조client-server">클라이언트 서버 구조(Client-Server)</h5>
<ul>
  <li>클라이언트-서버라는 구조로 각 부분의 개발 의존성을 최소화가 가능하다.</li>
</ul>

<h5 id="계층형-구조layered-system">계층형 구조(Layered System)</h5>
<ul>
  <li>순수 비즈니스로직, 인증, 암호화, 로드 밸런싱 등의 계층을 나누어 개발이 가능하다.</li>
</ul>

<h4 id="5-rest-안티패턴">5. REST 안티패턴</h4>
<h5 id="getpost를-이용한-터널링">GET/POST를 이용한 터널링</h5>
<ul>
  <li>http://myweb/users?method=update&amp;id=gildong 이 전형적인 GET을 이요한 터널링이다.</li>
  <li>즉 Method의 규약을 어기고 쿼리 파라미터로 데이터를 주고받는 방식은 REST가 아니다.</li>
</ul>

<h5 id="self-descriptiveness-속성을-사용하지-않음">Self-descriptiveness 속성을 사용하지 않음</h5>
<ul>
  <li>리소스의 URI와 Method, 그리고 정해진 포맷의 메세지 등으로 API가 구현되어야 하는데 위의 터널링처럼 규약을 지키지 않은 것을 의미한다.</li>
</ul>

<h5 id="http응답-코드를-사용하지-않음">HTTP응답 코드를 사용하지 않음</h5>
<ul>
  <li>200,403,404,500 등의 응답 코드를 사용해서 구현되어야 한다. 그렇지 않으면 REST라 할 수 없다.</li>
</ul>

