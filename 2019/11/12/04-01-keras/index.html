<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      머신러닝의 기본요소#1 &middot; Youngwon Seo
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">
</head>

  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-118401942-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118401942-1');
</script>

  <body>
    <nav class="nav">
      <div class="nav-container">
        <a href="/">
          <h2 class="nav-title">Youngwon Seo</h2>
        </a>
        <ul>
          <li><a href="/about">About</a></li>
          <li><a href="/">Posts</a></li>
          <li><a href="/study"/>Study</a></li>
          <li><a href="/ml"/>Machine Learning</a></li>
          <li><a href="/cicd"/>CI/CD</a></li>
          <!-- <li><a href="/spring"/>Spring</a></li>
          <li><a href="/deeplearning"/>Deeplearning</a></li> -->
        </ul>
    </div>
  </nav>

    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        Youngwon Seo
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2019-11-12 00:00:00 +0900">November 12, 2019</time>
    
  </div>

  <h1 class="post-title">머신러닝의 기본요소#1</h1>
  <div class="post-line"></div>

  <p>[케라스창시자에게 배우는 딥러닝]의 4장 내용을 정리한 것입니다.</p>

<p>앞까지의 내용을 통해 신경망을 사용하여 분류와 회귀에 대한 문제를 어떻게 해결하는지 경험하였습니다. 또한 머신러닝에서 아주 중요한 문제인 과대적합에 대해서도 경험하였습니다. 이번장부터는 앞까지의 내용을 좀더 확고한 개념으로 정립하고 모델 평가, 데이터 전처리, 특성공학, 과대적합 같은 개념을 포함한 <strong>머신러닝 문제를 해결하기 위한 7단계의 작업 흐름</strong>을 정리해보겠습니다.</p>

<h2 id="1-머신러닝의-4가지-분류">1. 머신러닝의 4가지 분류</h2>
<p>머신러닝에 대한 공부를 시작하다보면 처음 접하는 용어가 지도/비지도 학습입니다. 여기서는 머신러닝의 4가지 종류에 대해 집어봅니다.</p>

<h3 id="11-지도학습">1.1 지도학습</h3>
<p>이전의 이진 분류(영화 리뷰 분류), 다중 분류(뉴스 기사 분류), 회귀(주택 가격 예측)는 지도학습(supervised learning)에 속합니다. 데이터에서도 보았듯이 데이터(data, sample)를 데이터에 대한 타깃(target, label)으로 매핑하도록 학습하는 방법을 의미합니다(영화 리뷰에서는 리뷰문장이 데이터이고 긍/부정결과가 타깃이었습니다). 지도학습의 대부분은 분류(classification)와 회귀(regression)로 구성됩니다. 다음은 또 다른 지도학습으로 해결가능한 문제들입니다.</p>

<ul>
  <li>시퀀스 생성(sequence generation) : 사진등에 대해 설명을 하는 글(sentence)을 생성하는 문제, 글을 구성하는 단어(word)를 예측하는 문제</li>
  <li>구문 트리(syntax tree) 예측 : 문장이 주어지면 분해된 구문 트리를 예측</li>
  <li>문체 감지(object detection) : 사진이 주어지면 사진안에서 특정 물체를 탐지, 사진안의 자동차를 탐지 등의 문제</li>
  <li>이미지 분할(image segmentation) : object detection은 사진안의 물체를 네모 박스(bounding box)로 탐지하지만 분할(segmentation)은 픽셀단위로 그 모양 까지 정확하게 분류해내는 문제</li>
</ul>

<h3 id="12-비지도학습">1.2 비지도학습</h3>
<p>비지도학습(unsupervised learning)은 지도학습과 다르게 타겟이 없고 데이터만을 가지고 학습합니다. 데이터의 특성만 가지고 비슷한 데이터끼리 군집(clustering), 데이터 압축 및 차원 축소(dimensionality reduction) 등이 비지도 학습에 포합됩니다. 지도학습으로 학습전 데이터를 탐색할때 필수적으로 사용됩니다.</p>

<h3 id="13-자기-지도-학습">1.3 자기 지도 학습</h3>
<p>자기 지도 학습(self-supervised learning)은 지도학습의 특별한 경우이지만 별도의 볌주로 나눌만큼 충분히 다릅니다. 자기 지도 학습은 타겟값을 입력데이터로 부터 생성후 지도학습을 하는 것을 의미합니다. 오토인코더(autoencoder)가 자기 지도 학습의 대표적인 예로 입력데이터를 그대로 타켓으로 설정하는 신경망의 종류입니다.</p>

<h3 id="14-강화학습">1.4 강화학습</h3>
<p>강화학습(reinforcement learning)은 딥마인트(DeepMind)가 아타리 게임을 플레이하도록 학습하거나 바둑을 두는 알파고 같은 시스템을 개발하기 위해 사용된 알고리즘입니다. 강화학습은 에이전트(agent)가 환경(environment)에 대한 정보를 받아 어떻게 행동(action)했을때 최고의 보상(reward)을 환경으로 받을지를 스스로 학습합니다.</p>

<h2 id="2-머신러닝-모델-평가">2. 머신러닝 모델 평가</h2>
<p>머신러닝의 목표는 학습한 데이터가 아닌 처음 본 데이터에서 잘 작동하는 <strong>일반화된 모델</strong>을 얻는 것입니다. 즉 과대적합되지 않도록 모델을 학습시키는 것입니다. 여기서는 이를 위한 방법을 설명합니다.</p>

<h3 id="21-훈련-검증-테스트-세트">2.1 훈련, 검증, 테스트 세트</h3>
<p>모델이 과적합되지 않는다는 것은 주어진 데이터를 훈련, 검증, 테스트로 나누고 훈련데이터와 테스트데이터의 성능이 유사하게 또는 테스트데이터의 성능이 더 높게 나온다는 것을 의미합니다. 그렇다면 훈련과 테스트 데이터만 있으면 되는데 검증데이터가 존재하는 이유는 무엇일까요? 그것은 모델은 항상 튜닝(사용자가 입력하는 하이퍼파라미터(층수, 유닛개수, 학습률 등)를 변경하면서 모델의 성능을 높이는 작업) 되기 때문입니다. 모델을 튜닝하기 위해서는 훈련때 사용하지 않은 데이터로 모델이 평가되어야 하는데 이를 위해 테스트데이터가 사용되면 결국 테스트데이터에 과적합될 수 있습니다. 즉 이런식으로 모델의 성능을 올려도 그 성능은 테스트데이터에 과적합된 것이기 때문에 새로발생하는 데이터에 대해서는 성능을 보장할 수 없습니다!</p>

<p>정리해 보면 학습 데이터로 학습을 하고 검증 데이터로 평가한 후 성능에 따라 다시 모델을 튜닝합니다. 이후 다시 학습 데이터로 학습하고 검증세트로 평가하는 작업을 반복하다 마지막에 테스트데이터로 성능을 평가하는것이 정확한 평가입니다. 테스트 데이터는 모델을 결정하는 것에 아무런 영향을 미치지 않는 정말 성능 평가를 위한 데이터 셋입니다.</p>

<p>다음 학습, 검증, 테스트 데이터셋을 이용한 3가지 모델 평가 방법입니다.</p>

<h4 id="단순-홀드-아웃-검증">단순 홀드 아웃 검증</h4>
<p>단일 홀드 아웃 검증(hold-out validation)은 전체 데이터를 학습, 검증, 테스트 셋으로 나누고 학습데이터셋으로 학습, 검증데이터셋으로 검증 후 튜닝, 테스트로 성능을 평가하는 가장 기초적인 방법입니다. 자세한 설명은 코드와 주석으로 대체합니다.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">num_validation_samples</span> <span class="o">=</span> <span class="mi">10000</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">validation_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">num_validaion_samples</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">num_validation_samples</span><span class="p">:]</span>

<span class="n">training_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:]</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">get_model</span><span class="p">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>
<span class="n">validation_score</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">validation_data</span><span class="p">)</span>



<span class="n">model</span> <span class="o">=</span> <span class="n">get_model</span><span class="p">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">[</span><span class="n">training_data</span><span class="p">,</span> <span class="n">validation_data</span><span class="p">])</span>

<span class="n">test_score</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="k-겹-교차-검증">K-겹 교차 검증</h4>
<p>K-겹 교차 검증(K-fold cross-validation)은 학습 데이터(학습과 테스트로 나누어진 데이터에서 학습데이터를 의미)를 동일한 k개로 나누고 k-1개를 학습, 1개를 검증 데이터로 돌려 측정되는 성능의 평균을 가지고 모델을 평가하는 방법입니다. k개로 나누어진 각 세트는 모두 검증데이터를 한번씩 하기때문에 총 k번 학습과 평가가 이루어집니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">k</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">num_validation_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="n">validation_scores</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">fold</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
  <span class="n">validation_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">num_validation_samples</span> <span class="o">*</span> <span class="n">fold</span><span class="p">:</span> <span class="n">num_validation_samples</span> <span class="o">*</span> <span class="p">(</span><span class="n">fold</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="n">training_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">num_validation_samples</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">num_validation_samples</span> <span class="o">*</span> <span class="p">(</span><span class="n">fold</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span>

  <span class="n">model</span> <span class="o">=</span> <span class="n">get_model</span><span class="p">()</span>
  <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>
  <span class="n">validation_score</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluation</span><span class="p">(</span><span class="n">validation_data</span><span class="p">)</span>
  <span class="n">validation_scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">validation_score</span><span class="p">)</span>

  <span class="n">validation_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">validation_scores</span><span class="p">)</span>

  <span class="n">model</span> <span class="o">=</span> <span class="n">get_model</span><span class="p">()</span>
  <span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">test_score</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">test_data</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="셔플링을-사용한-k-겹-교차-검증">셔플링을 사용한 k-겹 교차 검증</h4>
<p>셔플링(shuffling)을 사용한 k-겹 교차 검증(iterated K-fold cross-validation)은 비교적 가용 데이터가 적고 정확하게 모델을 평가하고자 할때 사용됩니다. 이 방법은 K-겹 교차 검증을 여러번 적용하되, K개의 분할로 나누기전 매번 무작위 섞고 K-겹 교차 검증을 수행합니다. 즉 반복할 수(P)와 K가 정해지면 P X K 번의 학습 및 평가가 이루어져야해서 비용이 높다고 할 수 있습니다.</p>

<h2 id="3-데이터-전처리-특성-공학-특성-학습">3. 데이터 전처리, 특성 공학, 특성 학습</h2>

<h3 id="31-데이터-전처리">3.1 데이터 전처리</h3>
<p>신경망을 학습할려면 주어진 데이터를 신경망 입력에 적합하게 변형해야 합니다.</p>
<h4 id="백터화">백터화</h4>
<p>신경망의 모든 입력은 부동 소수데이터(필요에 따라 정수)로 이루어진 텐서입니다. 사운드, 이미지, 동영상 등 어떤것이든 텐서로 변환해서 신경망을 학습해야 합니다. 이렇게 텐서로 변환하는 것을 데이터 백터화(data vectorization)이라고 합니다. 앞 예제에서 영화 리뷰가 숫자로 이루어진 백터라는 것을 확인할 수 있었는데 이것인 이미 백터화가 되어 있는 데이터이기 때문입니다(더 정확하게는 원-핫 인코딩까지 포함해서 백터화라고 말할 수 있습니다).</p>

<h4 id="정규화">정규화</h4>
<p>정규화(regularization)는 입력되는 값을 일정한 범주 맞추는 것을 의미합니다. 이미지의 경우 한 픽셀의 값의 범위가 0~255가 될 수 있는데 255로 나누어 0~1의 값을 가지도록 정규화 할 수 있습니다. 이렇게 정규화를 하는 이유는 입력데이터를 기반으로 신경망의 가중치가 학습되는데 입력값이 너무 크거나 불균형적이면 가중치가 비용함수가 최소화되게 수렴하는 것을 방해합니다(경사하강법에서 그래디언트가 커지기 때문입니다). 따라서 네트워크를 쉽게 학습시킬려면 다음과 같이 데이터를 정규화 시킵니다.</p>
<ul>
  <li>작은 값을 취합니다. 0~1이 적당합니다.</li>
  <li>균일해야 합니다. 모든 특정이 같은 값의 범위를 취해야 합니다.</li>
</ul>

<p>추가적으로 자주 사용되는 정규화 방법입니다.</p>
<ul>
  <li>특성별 평균이 0, 표준편차가 1로 정규화합니다.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">-=</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c">#평균이 0이 되는 작업</span>
<span class="n">x</span> <span class="o">/=</span> <span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># 표준편차가 1이 되는 작업</span>
</code></pre></div>    </div>
    <p><strong>훈련세트에 사용된 정규화 방법은 테스트세트에서도 동일하게 이루어져야합니다.</strong></p>
  </li>
</ul>

<h4 id="누락된-값-다루기">누락된 값 다루기</h4>
<p>보통 NaN, Null로 처리되는 값으로 측정이 되지 않은 값을 의미합니다. 보통은 0으로 처리하거나 해당 데이터를 전체 데이터 세트에서 제거하고 진행합니다(0으로 취한할 경우는 취한되는 특성에 0값이 의미가 없어야 합니다).</p>

<h3 id="32-특성-공학">3.2 특성 공학</h3>

<h3 id="33-특성-학습">3.3 특성 학습</h3>



  
  <div class="post-disqus">
      <section id="disqus_thread"></section>
      <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://youngwonseo.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            
  </div>
  
</div>

<div class="pagination">
  
    <a href="/2019/11/13/sentence-classification-cnn/" class="left arrow">&#8592;</a>
  
  
    <a href="/2019/11/11/03-04-keras/" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
      <span>
        &copy; <time datetime="2020-03-04 00:15:58 +0900">2020</time> Youngwon Seo. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
      </span>
    </footer>
  </body>
</html>
