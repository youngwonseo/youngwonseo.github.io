<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>레디스 퀵스타트</title>
  <meta name="description" content="레디스란?">
  
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://youngwonseo.github.io/redis-quick-start/">
  <link rel="alternate" type="application/atom+xml" title="Graceful" href="https://youngwonseo.github.io/feed.xml" />  
  <link rel="stylesheet" href="/assets/css/syntax.css">
</head>

  <body>
    

<div class="header-container" id="header-container">

<!-- Site navigation -->
  <nav class="site-nav">
    <div class="trigger">
      
        
        <a class="page-link" href="/about/">About</a>
        
      
        
      
        
      
        
      
        
        <a class="page-link" href="/category/">Paper</a>
        
      
        
        <a class="page-link" href="/projects/">Projects</a>
        
      
        
        <a class="page-link" href="/study/">Study</a>
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
      <a class="page-link" href="/feed.xml">RSS</a>
    </div>
  </nav>

  <!-- The title of the site -->
  <header class="site-header">
    <!-- <a href="/">
      <div class="avatar">
        <img src="/assets/images/avatar.png" />
      </div>
    </a> -->
    <a class="site-title" href="/">Graceful</a>
  </header>

</div>

      <div class="wrapper">
        <div class="page-content">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">레디스 퀵스타트</h1>
    <p class="post-meta">February 17, 2019 • Youngwon Seo</p>
  </header>



  <article class="post-content">
    <h2 id="레디스란">레디스란?</h2>

<h2 id="레디스가-제공하는-데이터-타입">레디스가 제공하는 데이터 타입</h2>
<h2 id="문자열">문자열</h2>
<p>문자열은 정수, 부동소수정, 텍스트 문자열, 비트맵
최대 512MB</p>

<h3 id="set-get">SET, GET</h3>
<p>커맨트에서의 문자열 입출력실행해 봅시다. 
데이터 입력을 위해 <strong>SET</strong>을 사용하고 출력을 위해 <strong>GET</strong>을 사용합니다. SET의 첫 번째 값은 입력할 데이터의 키값이고 두 번째 값은 입력할 데이터의 벨류입니다. GET에 해당 키값을 주어 저장된 데이터를 검색합니다.</p>
<blockquote>
  <p>&gt; SET hello “hello world”
&gt; GET hello
“hello world”</p>
</blockquote>

<h3 id="mset-mget">MSET, MGET</h3>
<p>이번에는 SET과 GET대신 여러개의 키 벨류를 한꺼번에 처리하는 <strong>MSET</strong>과 <strong>MGET</strong>를 사용했습니다.</p>
<blockquote>
  <p>&gt; MSET first “First Key value” second “Second Key value”
&gt; MGET first second
1) “First Key value”
2) Second Key value</p>
</blockquote>

<h3 id="expire-ttl">EXPIRE, TTL</h3>
<p>EXPIRE는 데이터에 대한 만료시간(초 단위)을 지정합니다. 즉 다음과 같은 명령어를 수행하고 10초 위에 데이터를 검색하면 null이 반환됩니다(1이 반환되면 성공적으로 명령어가 수행되었다는 의미이고 0을 반환하면 키가 존재하지 않거나 설정할 수 없다는 의미입니다).</p>
<blockquote>
  <p>&gt; EXPIRE first 10
(integer) 1</p>
</blockquote>

<p>10초후…</p>
<blockquote>
  <p>&gt; GET first
(nil)</p>
</blockquote>

<p>TTL은 EXPIRE에 대한 남은 시간을 리턴합니다.</p>
<blockquote>
  <p>&gt; EXPIRE second 10
(interger) 1
&gt; TTL second
(integer) 9</p>
</blockquote>

<p>위의 예제에서 TTL을 반복적으로 수행하면 반환되는 값이 점점 줄어드는 것을 확인할 수 있습니다.
다음은 TTL의 반환값에 대한 설명입니다.</p>
<ul>
  <li>양의 정수 : 남은 시간(초 단위)</li>
  <li>-2 : 키가 존재하지 않거나 만료 됨</li>
  <li>-1 : EXPIRE가 지정이 되지 않음</li>
</ul>

<h3 id="incr-incrby-decr-decrby">INCR, INCRBY, DECR, DECRBY</h3>
<p>이름에서도 알 수 있듯이 입력된 값의 증가 및 감소 입니다. 
INCR와 INCRBY의 차이점은 INCR는 값을 하나씩 증가시키고 INCRBY는 주어진 값 만큼 증가시키는 것입니다. 값 감소를 수행하는 DECR와 DECRBY는 INCR와 INCRBY의 반대되는 명령어 입니다.</p>

<blockquote>
  <p>&gt; SET counter 100
OK
&gt; INCR counter
(integer) 101
&gt; INCRBY counter 10
(integer) 111
&gt; DECR counter
(integer) 110
&gt;DECRBY counter 50
(integer) 60
GET counter
“60”</p>
</blockquote>

<h2 id="싱글-스레드-기반">싱글 스레드 기반</h2>

<h2 id="리스트">리스트</h2>
<p>리스트는 콜렉션(collection), 스택(stack), 큐(queue) 등의 자료구조 처럼 동작할 수 있는 매우 유연한 데이터 타입입니다. 특히 레디스는 싱글스레드 기반이기 때문에 큐로 사용하면 병렬시스템에서 중복처리를 방지해줍니다. 또한 블로킹(blocking) 기능을 제공하기 때문에 비어있는 레디스에 접근시 새로운 데이터가 발생할때 까지 대기시킬 수도 있습니다.
레디스의 리스트는 연결 리스트(linked list)이기 때문에 추가 및 삭제는 O(1)의 성능을 보장하고 검색은 O(n)의 성능을 가집니다. 이것은 병렬처리 및 분산처리에서 이벤트 처리를 위한 스케줄링 큐로 사용에 적합한 특징을 나타냅니다(실제로 해당 용도로 많이 사용됩니다).</p>

<h3 id="lpush-rpush">LPUSH, RPUSH</h3>
<p>LPUSH는 좌측(처음)에 입력 RPUSH는 우측(마지막)에 입력하는 명령어입니다.</p>
<blockquote>
  <p>&gt; LPUSH books “Effective Java”
(integer) 1
&gt; RPUSH books “Clean Code”
(integer) 2</p>
</blockquote>

<p>LPUSH와 RPUSH는 수행 후 리스트의 크기를 반환합니다. 또한 한번에 여러개의 값을 넣을 수 있습니다.</p>
<blockquote>
  <p>&gt; LPUSH books “Learning Nodejs” “Python”
(integer) 4</p>
</blockquote>

<h3 id="llen-lindex">LLEN, LINDEX</h3>
<p>LLEN은 리스트의 크기를 반환하고 LINDEX는 해당 인덱스의 값을 반환합니다.</p>
<blockquote>
  <p>&gt; LLEN books
(integer) 4
&gt; LINDEX books 2
“Effective Java”</p>
</blockquote>

<h3 id="lrange">LRANGE</h3>
<p>LRANGE는 주어지는 두개의 인덱스 범위에 속한 값들을 배열로 반환합니다. 주어지는 인덱스를 포함한 범위를 반환합니다.</p>
<blockquote>
  <p>&gt; LRANGE books 0 1
1) “Python”
2) “Learning Nodejs”</p>
</blockquote>

<h3 id="lpop-rpop">LPOP, RPOP</h3>
<p>LPOP은 좌측(처음) 데이터를 반환하고 반환된 데이터는 리스트에서 삭제합니다. RPOP은 우측(마지막) 데이터를 반환하고 리스트에서 삭제합니다.</p>

<blockquote>
  <p>&gt; LPOP books
“Python”</p>
</blockquote>

<p>위 명령어들을 사용해서 연결 리스트로 구현되어 있는 레디스의 리스트가 어떻게 큐나 스택으로 이용될 수 있는지 감이 올 것입니다. 만약 감이 오지 않는다면 <strong>자료구조</strong>를 참조해주세요(개발자라면 무조건 감이 와야하는 내용입니다).</p>

<h2 id="해시">해시</h2>
<p>해시는 키와 값으로 매핑되는 데이터 타입니다. 내부적으로 집리스트(ziplist)또는 해시 테이블(hash table)이 될 수 있다. 집리스트는 메모리 효율화에 목적을 둔 양방향 연결 리스트이다. 해시 테이블은 검색 최적화에 목적을 둔 자료구조 이지만 메모리 최적화가 이루어 지지 안습니다.</p>

<h3 id="hset-hmset">HSET, HMSET</h3>
<p>HSET은 하나의 키 값쌍을, HMSET은 여러개의 키 값 쌍을 입력합니다.</p>
<blockquote>
  <p>&gt; HSET movie “title” “the Godfather”
(integer) 1
&gt; HMSET movie “year” 1972 “rating” 9.2 “watchers” 10000000
OK</p>
</blockquote>

<p>movie라는 객체에 키, 벨류 쌍을 입력하였습니다.</p>

<h3 id="hincrby-hincrbyfloat">HINCRBY, HINCRBYFLOAT,</h3>

<h3 id="hget-hmget-hgetall">HGET, HMGET, HGETALL</h3>
<p>HGET은 하나의 키에 대한 값을, HMGET은 여러개의 키에 대한 값을 배열로, HGETALL은 객체의 모든 키, 값을 배열로 반환합니다. 이때 HGETALL은 키, 값을 1차원의 배열로 반환합니다.</p>

<blockquote>
  <p>&gt; HGET movie “title”
“the Godfather”
&gt; HMGET movie “title” “watchers”
1) “the Godfather”
2) “10000000”
&gt; HGETALL
1) “title”
2) “the Godfather”
3) “year”
4) “1972”
5) “rating”
6) “9.2”
7) “watchers”
8) “10000000”</p>
</blockquote>

<h3 id="hdel">HDEL</h3>
<p>HDEL은 입력된 키에 대한 키,값쌍을  객체에서 삭제합니다.</p>

<blockquote>
  <p>&gt; HDEL movie “watchers”
(integer) 1</p>
</blockquote>

<h3 id="hkeys-hvals">HKEYS, HVALS</h3>
<p>HKEYS는 해당 객체의 키를 배열로 반환, HVALS은 해당 객체의 값을 배열로 반환합니다.</p>

<blockquote>
  <p>&gt; HKEYS movie
1) “title”
2) “year”
3) “rating”</p>
</blockquote>

<blockquote>
  <p>&gt; HVALS movie
1) “the Godfather”
2) “1972”
3) “9.2”</p>
</blockquote>

<h2 id="셋">셋</h2>
<p>셋은 수학에서 집합과 동일한 자료구조입니다. 특징은 순서가 없고 동일한 값이 존재하지 않습니다. 또한 수학에서의 집합 연산과 동일한 연산들이 제공됩니다.
레디스는 셋의 일부 명령어들을 최적화 하기 위해 해시 테이블을 사용해서 구현했습니다.</p>

<h3 id="sadd">SADD</h3>
<p>SADD는 셋에 하나이상의 데이터를 추가합니다. 입력된 데이터의 개수를 반환합니다. 각각의 다른 셋에 4개 그리고 3개의 데이터를 입력합니다.</p>
<blockquote>
  <p>&gt; SADD user:max:favorite_artists “Arcade Fire” “Arctic Monkeys” “Belle &amp; Sebastian” “Lenine”
(integer) 4
&gt; SADD user:hugo:favorite_artists “Daft Punk” “The Kooks” “Arctic Monkeys”
(integher) 3</p>
</blockquote>

<h3 id="sinter">SINTER</h3>
<p>SINTER는 하나이상의 셋으로 부터 공통된 값들을 배열로 반환합니다. 즉 교집합을 반환합니다.</p>
<blockquote>
  <p>&gt; SINTER user:max:favorite_artists user:hugo:favorite_artists
1) “Arctic Monkeys”</p>
</blockquote>

<h3 id="sdiff">SDIFF</h3>
<p>SDIFF는 하나이상의 셋으로 부터 가장 첫 번째 셋에서 나머지 셋의 차집합을 반환합니다.
즉 아래의 경우 user:max:favorite_artists 값들에서 user:hugo:favorite_artists의 값들을 제외한 값을 배열로 반환합니다.</p>
<blockquote>
  <p>&gt; SDIFF user:max:favorite_artists user:hugo:favorite_artists
1) “Belle &amp; Sebastian”
2) “Arcade Fire”
3) “Lenine”</p>
</blockquote>

<blockquote>
  <p>&gt;  SDIFF user:hugo:favorite_artists user:max:favorite_artists
1) “Daft Punk”
2) “The Kooks”</p>
</blockquote>

<h3 id="sunion">SUNION</h3>
<p>SUNION은 하나이상의 셋의 합을 배열로 반환합니다. 즉 합집합에 해당합니다. 여기서 셋의 특성상 공통된 값들은 하나만 반환합니다.</p>
<blockquote>
  <p>&gt; SUNION user:max:favorite_artists user:hugo:favorite_artists
1) “Arcade Fire”
 2) “Lenine”
3) “Belle &amp; Sebastian”
4) “Daft Punk”
5) “Arctic Monkeys”
6) “The Kooks”</p>
</blockquote>

<h3 id="srandmember">SRANDMEMBER</h3>
<p>SRANDMEMBER는 셋에서 하나의 무작위 값을 반환합니다.</p>

<h3 id="sismember">SISMEMBER</h3>
<p>SISMEMBER는 셋에 해당 값이 존재하는지 확인합니다.</p>

<h3 id="srem">SREM</h3>
<p>SREM은 주어진 값이 셋에 존재하면 삭제하고 셋의 크기를 반환합니다.</p>

<h3 id="smembers">SMEMBERS</h3>
<p>SMEMBERS는 셋에 입력된 값전체를 배열로 반환합니다.</p>

<h2 id="정렬된-셋">정렬된 셋</h2>
<p>셋과 비슷하지만 순서를 가지고 있습니다.</p>

<h3 id="zadd">ZADD</h3>
<p>ZADD는 정렬된 셋에 데이터를 입력하는 명령어 입니다. 셋이름과 점수와 엘리먼트를 추가합니다. 두 가지 정렬기준인 점수와 값이 있으며 점수가 같을 시 엘리먼트가 사전순으로 정렬됩니다.</p>

<blockquote>
  <p>&gt; ZADD leaders 100 “Alice”
(integer) 1
&gt; ZADD leaders 100 “Zed”
(integer) 1
&gt; ZADD leaders 102 “Hugo”
(integer) 1
&gt; ZADD leaders 101 “Max”
(integer) 1</p>
</blockquote>

<h3 id="zrange-zrevrange">ZRANGE, ZREVRANGE</h3>
<p>ZRANGE와 ZREVRANGE는 셋에 대해 시작 인덱스와 종료인덱스를 기반으로 포함된 값들을 배열로 반환합니다.</p>

<h3 id="zrem">ZREM</h3>
<p>ZREM은 해당 엘리먼트를 삭제합니다.</p>

<h3 id="zscore">ZSCORE</h3>
<p>ZSCORE는 엘리먼드의 점수를 반환합니다.</p>

<h3 id="zrank">ZRANK</h3>
<p>ZRANK는 입력된 엘리먼트의 등수를 반환합니다. 점수가 오름순으로 정렬되어 있으며 가장 낮은 점수를 가진 엘리먼트가 0 순위입니다.</p>

<h3 id="zrevrank">ZREVRANK</h3>
<p>ZREVRANK는 ZRANK와 반대로 내림차순에서의 등수를 반환합니다. 가장 높은 점수를 가진 엘리먼트가 0 순위입니다.</p>

<p>ZRANGEBYLEX, ZRANGEBYSCORE, ZREVRANGE, ZREVRANGEBYLEX, ZREVRANGEBYSCORE</p>

<h2 id="비트맵">비트맵</h2>

<h3 id="setbit">SETBIT</h3>

<h3 id="getbit">GETBIT</h3>

<h3 id="bitcount">BITCOUNT</h3>

<h3 id="bitop">BITOP</h3>

<h2 id="하이퍼로그">하이퍼로그</h2>

<h3 id="pfadd">PFADD</h3>
<h3 id="pfcount">PFCOUNT</h3>
<h3 id="pfmerge">PFMERGE</h3>

  </article>

  <hr>

  <!-- <div class="question">
    <h2>Questions?</h2>
    <p>Have a question regarding the post above? <br />Or any of my designs?</p>
    

  </div> -->

  <div class="related">
    <h2>Related</h2>
    
      <li><a href="/again-probability/" title="[길벗] 다시 확률통계 확률편 리뷰">[길벗] 다시 확률통계 확률편 리뷰
       &nbsp; <span class="post-meta">January 06, 2021</span></a>
    
      <li><a href="/debounce-throttle/" title="자바스크립트 - 실시간검색과 무한스크롤(디바운스와 스로틀) ">자바스크립트 - 실시간검색과 무한스크롤(디바운스와 스로틀) 
       &nbsp; <span class="post-meta">January 05, 2021</span></a>
    
      <li><a href="/image-resize/" title="파이썬 이미지 리사이즈">파이썬 이미지 리사이즈
       &nbsp; <span class="post-meta">October 09, 2020</span></a>
    
  </div>

</div>

        </div>
        <footer class="site-footer">
<p class="small">YOUNGWON &copy 2021
</p>
</footer>

    </div>

    <script src="//cdn.jsdelivr.net/headroomjs/0.5.0/headroom.min.js"></script>
    <script type="text/javascript">
      var el = document.querySelector(".header-container");
      var headroom  = new Headroom(el, {
        "offset": 205,
        "tolerance": 5
      });
      headroom.init();
    </script>


    <!-- Twitter Shizzle -->
    <script type="text/javascript">
    window.twttr = (function (d, s, id) {
      var t, js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src= "https://platform.twitter.com/widgets.js";
      fjs.parentNode.insertBefore(js, fjs);
      return window.twttr || (t = { _e: [], ready: function (f) { t._e.push(f) } });
    }(document, "script", "twitter-wjs"));
    </script>

  </body>
</html>
