<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">
  
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>몽고DB - 스토리지 엔진 | 서영원 블로그</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="몽고DB - 스토리지 엔진" />
<meta name="author" content="Youngwon Seo" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="다른 DBMS와 마찬가지로 몽고DB도 스토리지 엔진(Storage Engine)이 여러가지가 존재합니다. 스토리지 엔진은 사용자의 데이터를 디스크에 영구적으로 저장하거나 다시 읽어와 메모리에 적재하는 역활을 담당합니다. 즉 조회, 저장등의 쿼리를 실행하면 옵티아미저(Optimizer)가 실행계획을 최적화하는데, 이후 디스크에서 데이터를 읽어오고 저장하는 작업을 최적으로 선택하는것이 스토리지 엔진이 역활입니다. 아래의 그림에서 MMAP V1, Wired Tiger가 스토리지 엔진이며 다른 DBMS와 다르게 하나의 인스턴스에 여러가지 스토리지를 사용할 수는 없습니다. 대신 샤딩을 통해 여러 머신에서 각각의 스토리지 엔진을 결정하여 사용하는 형태입니다. ![](http://s3.amazonaws.com/info-mongodb-com/_com_assets/blog/figure2.png" />
<meta property="og:description" content="다른 DBMS와 마찬가지로 몽고DB도 스토리지 엔진(Storage Engine)이 여러가지가 존재합니다. 스토리지 엔진은 사용자의 데이터를 디스크에 영구적으로 저장하거나 다시 읽어와 메모리에 적재하는 역활을 담당합니다. 즉 조회, 저장등의 쿼리를 실행하면 옵티아미저(Optimizer)가 실행계획을 최적화하는데, 이후 디스크에서 데이터를 읽어오고 저장하는 작업을 최적으로 선택하는것이 스토리지 엔진이 역활입니다. 아래의 그림에서 MMAP V1, Wired Tiger가 스토리지 엔진이며 다른 DBMS와 다르게 하나의 인스턴스에 여러가지 스토리지를 사용할 수는 없습니다. 대신 샤딩을 통해 여러 머신에서 각각의 스토리지 엔진을 결정하여 사용하는 형태입니다. ![](http://s3.amazonaws.com/info-mongodb-com/_com_assets/blog/figure2.png" />
<link rel="canonical" href="https://youngwonseo.github.io/mongodb-storage-engine/" />
<meta property="og:url" content="https://youngwonseo.github.io/mongodb-storage-engine/" />
<meta property="og:site_name" content="서영원 블로그" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-11T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="몽고DB - 스토리지 엔진" />
<script type="application/ld+json">
{"datePublished":"2019-06-11T00:00:00+09:00","url":"https://youngwonseo.github.io/mongodb-storage-engine/","mainEntityOfPage":{"@type":"WebPage","@id":"https://youngwonseo.github.io/mongodb-storage-engine/"},"dateModified":"2019-06-11T00:00:00+09:00","author":{"@type":"Person","name":"Youngwon Seo"},"description":"다른 DBMS와 마찬가지로 몽고DB도 스토리지 엔진(Storage Engine)이 여러가지가 존재합니다. 스토리지 엔진은 사용자의 데이터를 디스크에 영구적으로 저장하거나 다시 읽어와 메모리에 적재하는 역활을 담당합니다. 즉 조회, 저장등의 쿼리를 실행하면 옵티아미저(Optimizer)가 실행계획을 최적화하는데, 이후 디스크에서 데이터를 읽어오고 저장하는 작업을 최적으로 선택하는것이 스토리지 엔진이 역활입니다. 아래의 그림에서 MMAP V1, Wired Tiger가 스토리지 엔진이며 다른 DBMS와 다르게 하나의 인스턴스에 여러가지 스토리지를 사용할 수는 없습니다. 대신 샤딩을 통해 여러 머신에서 각각의 스토리지 엔진을 결정하여 사용하는 형태입니다. ![](http://s3.amazonaws.com/info-mongodb-com/_com_assets/blog/figure2.png","@type":"BlogPosting","headline":"몽고DB - 스토리지 엔진","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  
  
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://youngwonseo.github.io/mongodb-storage-engine/">
  <link rel="alternate" type="application/atom+xml" title="서영원 블로그" href="https://youngwonseo.github.io/feed.xml" />  
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/moonspam/NanumBarunGothic@latest/nanumbarungothicsubset.css">
  <link rel="stylesheet" href="/assets/css/syntax.css">
</head>

  <body>
    

<div class="header-container" id="header-container">

<!-- Site navigation -->
  <nav class="site-nav">
    <div class="trigger">
      
        
        <a class="page-link" href="/about/">About</a>
        
      
        
        <a class="page-link" href="/archive/">Archive</a>
        
      
        
      
        
      
        
      
        
        <a class="page-link" href="/category/">Paper</a>
        
      
        
        <a class="page-link" href="/projects/">Projects</a>
        
      
        
        <a class="page-link" href="/study/">Study</a>
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
      <a class="page-link" href="/feed.xml">RSS</a>
    </div>
  </nav>

  <!-- The title of the site -->
  <header class="site-header">
    <!-- <a href="/">
      <div class="avatar">
        <img src="/assets/images/avatar.png" />
      </div>
    </a> -->
    <a class="site-title" href="/">서영원 블로그</a>
  </header>

</div>

      <div class="wrapper">
        <div class="page-content">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">몽고DB - 스토리지 엔진</h1>
    <p class="post-meta">2019-06-11 / Youngwon Seo</p>
  </header>



  <article class="post-content">
    <p>다른 DBMS와 마찬가지로 몽고DB도 스토리지 엔진(Storage Engine)이 여러가지가 존재합니다.  스토리지 엔진은 사용자의 데이터를 디스크에 영구적으로 저장하거나 다시 읽어와 메모리에 적재하는 역활을 담당합니다. 즉 조회, 저장등의 쿼리를 실행하면 옵티아미저(Optimizer)가 실행계획을 최적화하는데, 이후 <strong>디스크에서 데이터를 읽어오고 저장하는 작업을 최적으로 선택하는것이 스토리지 엔진이 역활</strong>입니다. 아래의 그림에서 MMAP V1, Wired Tiger가 스토리지 엔진이며 다른 DBMS와 다르게 하나의 인스턴스에 여러가지 스토리지를 사용할 수는 없습니다. 대신 샤딩을 통해 여러 머신에서 각각의 스토리지 엔진을 결정하여 사용하는 형태입니다.
![](<a href="http://s3.amazonaws.com/info-mongodb-com/_com_assets/blog/figure2.png">http://s3.amazonaws.com/info-mongodb-com/_com_assets/blog/figure2.png</a></p>

<p>몽고DB는 다음과 같은 스토리지 엔진을 제공합니다.</p>
<ul>
  <li>MMAP v1</li>
  <li>WiredTiger</li>
  <li>In-Memory</li>
  <li>RocksDB</li>
  <li>TokuDB
각각의 스토리지엔진들은 장단점이 다르기 때문에 사용용도에 따라 적합하게 선택해야합니다. 장단점은 다르지만 모든 스토리지 엔진의 쿼리나 DML은 같으므로 응용단의 변경없이 스토리지 엔진을 변경할 수 있습니다.</li>
</ul>

<p>다음은 각각의 스토리지엔진을 간략하게 비교한 표입니다(In-Memory는 엔터프라이즈 버전에서만 사용가능하고 아래의 표에서는  WiredTiger로 분류되었습니다).</p>

<table>
  <tbody>
    <tr>
      <td>기능</td>
      <td>MMAPv1</td>
      <td>WiredTiger</td>
      <td>RocksDB</td>
      <td>TokuDB</td>
    </tr>
    <tr>
      <td>잠금 수준</td>
      <td>컬렉션</td>
      <td>도큐먼트</td>
      <td>도큐먼트</td>
      <td>도큐먼트</td>
    </tr>
    <tr>
      <td>데이터 구조</td>
      <td>B-Tree</td>
      <td>B-Tree</td>
      <td>LSM</td>
      <td>Fractal-Tree</td>
    </tr>
    <tr>
      <td>빌트인 캐시</td>
      <td>X(운영체제 캐시</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>세컨트리 인덱스</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>데이터 압축</td>
      <td>X</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>인덱스 압축</td>
      <td>X</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>암호화</td>
      <td>X</td>
      <td>O</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td>In-Memory 지원</td>
      <td>X</td>
      <td>O</td>
      <td>X</td>
      <td>X</td>
    </tr>
    <tr>
      <td>컬렉션 파티션</td>
      <td>X</td>
      <td>X</td>
      <td>X</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>그럼 각 스토리지엔진의 특성에 대해 살펴보겠습니다. 여기서는 최대한 간략하세 설명하고 자세한 내용은 <a href="[http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;orderClick=LEB&amp;barcode=9791158390921](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;orderClick=LEB&amp;barcode=9791158390921)">책(Real MongoDB)</a> 을 읽어주세요.</p>

<h2 id="2-mmapv1-스토리지-엔진">2. MMAPv1 스토리지 엔진</h2>

<h3 id="21-mmapv1-설정">2.1 MMAPv1 설정</h3>
<p>몽고DB는 스토리지엔진과 별게로 공통 설정 항목과 각 스토리지엔진별 설정 항목이 존재합니다. 공통 설정항목은 다음으로 설명할 몽고DB의 디폴트 스토리지 엔진인 WiredTiger에서 설명하고 여기서는 MMAPv1의 설정 항목을 살펴보겠습니다.</p>

<ul>
  <li>preallocDataFiles :</li>
  <li>nsSize :</li>
  <li>quota :
    <ul>
      <li>enforced :</li>
      <li>maxFilesPerDB :</li>
    </ul>
  </li>
  <li>smallFiles :</li>
</ul>

<h3 id="22-데이터-파일-구조">2.2 데이터 파일 구조</h3>

<h3 id="23-서버상태-확인">2.3 서버상태 확인</h3>
<h3 id="24-운영체제-캐시">2.4 운영체제 캐시</h3>
<h3 id="25-데이터-파일-프레크멘테이션">2.5 데이터 파일 프레크멘테이션</h3>

<h2 id="3-wiredtiger-스토리지-엔진몽고db-디폴트">3. WiredTiger 스토리지 엔진(몽고DB 디폴트)</h2>
<p>Berkeley DB 개발자들이 개발한 임베디드 DB엔진으로 몽고DB에 인수되었고 지금은 몽고DB의 디폴트 스토리지 엔진입니다. 위의 MMAPv1의 문제점을 해결하기 위해 몽고DB에 흡수되었고 디폴트로 사용되는 것이죠.</p>

<h3 id="31-wiredtiger-설정">3.1 WiredTiger 설정</h3>
<p>먼저 모든 스토리지 엔진에서 설정가능한 공통설정인 storage: 부분을 살펴보겠습니다.</p>
<ul>
  <li>dbPath</li>
  <li>indexBuildRetry</li>
  <li>repairPath</li>
  <li>directoryPerDB</li>
  <li>syncPeriodSecs</li>
  <li>journal</li>
  <li>engine - 사용할 스토리지 엔진을 명시(MMAPv1, WiredTiger, 등)</li>
</ul>

<p>다음은 WiredTiger의 설정항목입니다.</p>
<ul>
  <li>engineConfig.cacheSizeGB -</li>
  <li>collectionConfig.blockCompressor -</li>
  <li>indexConfig.prefixCompression -</li>
</ul>

<h3 id="32-저장방식">3.2 저장방식</h3>
<p>WiredTiger은 3가지 타입의 저장소를 가지고 있습니다.</p>
<h4 id="321-레코드row-record-스토어">3.2.1 레코드(Row, Record) 스토어</h4>
<h4 id="322-컬럼-스토어">3.2.2 컬럼 스토어</h4>
<h4 id="323-lsmlog-structured-merge-tree-스토어">3.2.3 LSM(Log Structured Merge Tree) 스토어</h4>

<h3 id="33-데이터-파일-구조">3.3 데이터 파일 구조</h3>
<p>WiredTiger는 MMAPv1과는 완전히 다른 파일구조를 사용합니다.</p>

<h3 id="34-내부-동작-방식">3.4 내부 동작 방식</h3>
<p>WiredTiger는 트랜젝션을 지원하는  대부분의 RDBMS와 흡사한 내부 구조를 가지고 있습니다(몽고DB서버는 트랙젝션을 지원하지 않음). 
[그림]</p>

<h3 id="35-공유캐시">3.5 공유캐시</h3>
<h3 id="36-캐시-이빅션cache-eviction">3.6 캐시 이빅션(Cache Eviction)</h3>
<h3 id="36-체크포인트">3.6 체크포인트</h3>
<h3 id="37-mvcc">3.7 MVCC</h3>
<h3 id="38-데이터-블록">3.8 데이터 블록</h3>
<h3 id="39-운영체제-캐시">3.9 운영체제 캐시</h3>

<h2 id="4-메모리-스토리지-엔진">4. 메모리 스토리지 엔진</h2>

<h2 id="5-기타-스토리지-엔진">5. 기타 스토리지 엔진</h2>

<h2 id="references">References</h2>
<ul>
  <li><a href="http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;ejkGb=KOR&amp;orderClick=LEB&amp;barcode=9791158390921">Real MongoDB 2장 스토리지 엔진</a></li>
  <li></li>
</ul>

  </article>

  <hr>

  <!-- <div class="question">
    <h2>Questions?</h2>
    <p>Have a question regarding the post above? <br />Or any of my designs?</p>
    

  </div> -->

  <!-- <div class="related">
    <h2>Related</h2>
    
      <li><a href="/artillery/artillery-intro/" title="소프트웨어 부하 테스트 도구 Artillery 소개">소프트웨어 부하 테스트 도구 Artillery 소개
       &nbsp; <span class="post-meta">February 17, 2021</span></a>
    
      <li><a href="/kubernetes/replica-set/" title="쿠버네티스 - 레프리카셋(Replica Set)">쿠버네티스 - 레프리카셋(Replica Set)
       &nbsp; <span class="post-meta">February 16, 2021</span></a>
    
      <li><a href="/kubernetes/pod/" title="쿠버네티스 - 포드(Pod)">쿠버네티스 - 포드(Pod)
       &nbsp; <span class="post-meta">February 15, 2021</span></a>
    
  </div> -->

  
  
    <div id="disqus_thread"></div>
    <script>
        /**
        *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
        /*
        var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        */
        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://youngwonseo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  

</div>

        </div>
        <footer class="site-footer">
<p class="small"></p>
</footer>

    </div>

    <script src="//cdn.jsdelivr.net/headroomjs/0.5.0/headroom.min.js"></script>
    <script type="text/javascript">
      var el = document.querySelector(".header-container");
      var headroom  = new Headroom(el, {
        "offset": 205,
        "tolerance": 5
      });
      headroom.init();
    </script>


    <!-- Twitter Shizzle -->
    <script type="text/javascript">
    window.twttr = (function (d, s, id) {
      var t, js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src= "https://platform.twitter.com/widgets.js";
      fjs.parentNode.insertBefore(js, fjs);
      return window.twttr || (t = { _e: [], ready: function (f) { t._e.push(f) } });
    }(document, "script", "twitter-wjs"));
    </script>

  </body>
</html>
