<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">
  
  <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>몽고DB - 스토리지 엔진 | 서영원 블로그</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="몽고DB - 스토리지 엔진" />
<meta name="author" content="Youngwon Seo" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="다른 DBMS와 마찬가지로 몽고DB도 스토리지 엔진(Storage Engine)이 여러가지가 존재합니다. 스토리지 엔진은 사용자의 데이터를 디스크에 영구적으로 저장하거나 다시 읽어와 메모리에 적재하는 역활을 담당합니다. 즉 조회, 저장등의 쿼리를 실행하면 옵티아미저(Optimizer)가 실행계획을 최적화하는데, 이후 디스크에서 데이터를 읽어오고 저장하는 작업을 최적으로 선택하는것이 스토리지 엔진이 역활입니다. 아래의 그림에서 MMAP V1, Wired Tiger가 스토리지 엔진이며 다른 DBMS와 다르게 하나의 인스턴스에 여러가지 스토리지를 사용할 수는 없습니다. 대신 샤딩을 통해 여러 머신에서 각각의 스토리지 엔진을 결정하여 사용하는 형태입니다." />
<meta property="og:description" content="다른 DBMS와 마찬가지로 몽고DB도 스토리지 엔진(Storage Engine)이 여러가지가 존재합니다. 스토리지 엔진은 사용자의 데이터를 디스크에 영구적으로 저장하거나 다시 읽어와 메모리에 적재하는 역활을 담당합니다. 즉 조회, 저장등의 쿼리를 실행하면 옵티아미저(Optimizer)가 실행계획을 최적화하는데, 이후 디스크에서 데이터를 읽어오고 저장하는 작업을 최적으로 선택하는것이 스토리지 엔진이 역활입니다. 아래의 그림에서 MMAP V1, Wired Tiger가 스토리지 엔진이며 다른 DBMS와 다르게 하나의 인스턴스에 여러가지 스토리지를 사용할 수는 없습니다. 대신 샤딩을 통해 여러 머신에서 각각의 스토리지 엔진을 결정하여 사용하는 형태입니다." />
<link rel="canonical" href="https://youngwonseo.github.io/mongodb-instruction/" />
<meta property="og:url" content="https://youngwonseo.github.io/mongodb-instruction/" />
<meta property="og:site_name" content="서영원 블로그" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-08T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="몽고DB - 스토리지 엔진" />
<script type="application/ld+json">
{"url":"https://youngwonseo.github.io/mongodb-instruction/","author":{"@type":"Person","name":"Youngwon Seo"},"headline":"몽고DB - 스토리지 엔진","dateModified":"2019-06-08T00:00:00+09:00","datePublished":"2019-06-08T00:00:00+09:00","description":"다른 DBMS와 마찬가지로 몽고DB도 스토리지 엔진(Storage Engine)이 여러가지가 존재합니다. 스토리지 엔진은 사용자의 데이터를 디스크에 영구적으로 저장하거나 다시 읽어와 메모리에 적재하는 역활을 담당합니다. 즉 조회, 저장등의 쿼리를 실행하면 옵티아미저(Optimizer)가 실행계획을 최적화하는데, 이후 디스크에서 데이터를 읽어오고 저장하는 작업을 최적으로 선택하는것이 스토리지 엔진이 역활입니다. 아래의 그림에서 MMAP V1, Wired Tiger가 스토리지 엔진이며 다른 DBMS와 다르게 하나의 인스턴스에 여러가지 스토리지를 사용할 수는 없습니다. 대신 샤딩을 통해 여러 머신에서 각각의 스토리지 엔진을 결정하여 사용하는 형태입니다.","mainEntityOfPage":{"@type":"WebPage","@id":"https://youngwonseo.github.io/mongodb-instruction/"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  
  
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://youngwonseo.github.io/mongodb-instruction/">
  <link rel="alternate" type="application/atom+xml" title="서영원 블로그" href="https://youngwonseo.github.io/feed.xml" />  
  <link rel="stylesheet" href="/assets/css/syntax.css">
</head>

  <body>
    

<div class="header-container" id="header-container">

<!-- Site navigation -->
  <nav class="site-nav">
    <div class="trigger">
      
        
        <a class="page-link" href="/about/">About</a>
        
      
        
        <a class="page-link" href="/archive/">Archive</a>
        
      
        
      
        
      
        
      
        
        <a class="page-link" href="/category/">Paper</a>
        
      
        
        <a class="page-link" href="/projects/">Projects</a>
        
      
        
        <a class="page-link" href="/study/">Study</a>
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
      <a class="page-link" href="/feed.xml">RSS</a>
    </div>
  </nav>

  <!-- The title of the site -->
  <header class="site-header">
    <!-- <a href="/">
      <div class="avatar">
        <img src="/assets/images/avatar.png" />
      </div>
    </a> -->
    <a class="site-title" href="/">서영원 블로그</a>
  </header>

</div>

      <div class="wrapper">
        <div class="page-content">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">몽고DB - 스토리지 엔진</h1>
    <p class="post-meta">2019-06-08 / Youngwon Seo</p>
  </header>



  <article class="post-content">
    <p>다른 DBMS와 마찬가지로 몽고DB도 스토리지 엔진(Storage Engine)이 여러가지가 존재합니다.  스토리지 엔진은 사용자의 데이터를 디스크에 영구적으로 저장하거나 다시 읽어와 메모리에 적재하는 역활을 담당합니다. 즉 조회, 저장등의 쿼리를 실행하면 옵티아미저(Optimizer)가 실행계획을 최적화하는데, 이후 <strong>디스크에서 데이터를 읽어오고 저장하는 작업을 최적으로 선택하는것이 스토리지 엔진이 역활</strong>입니다. 아래의 그림에서 MMAP V1, Wired Tiger가 스토리지 엔진이며 다른 DBMS와 다르게 하나의 인스턴스에 여러가지 스토리지를 사용할 수는 없습니다. 대신 샤딩을 통해 여러 머신에서 각각의 스토리지 엔진을 결정하여 사용하는 형태입니다.</p>

<p><img src="http://s3.amazonaws.com/info-mongodb-com/_com_assets/blog/figure2.png" alt="" /></p>

<p>몽고DB는 다음과 같은 스토리지 엔진을 제공합니다.</p>
<ul>
  <li>MMAP v1</li>
  <li>WiredTiger</li>
  <li>In-Memory</li>
  <li>RocksDB</li>
  <li>TokuDB</li>
</ul>

<p>각각의 스토리지엔진들은 장단점이 다르기 때문에 사용용도에 따라 적합하게 선택해야합니다. 장단점은 다르지만 모든 스토리지 엔진의 쿼리나 DML은 같으므로 응용단의 변경없이 스토리지 엔진을 변경할 수 있습니다.</p>

<p>다음은 각각의 스토리지엔진을 간략하게 비교한 표입니다(In-Memory는 엔터프라이즈 버전에서만 사용가능하고 아래의 표에서는  WiredTiger로 분류되었습니다).</p>

<table>
  <tbody>
    <tr>
      <td>기능</td>
      <td>MMAPv1</td>
      <td>WiredTiger</td>
      <td>RocksDB</td>
      <td>TokuDB</td>
    </tr>
    <tr>
      <td>잠금 수준</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>데이터 구조</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>빌트인 캐시</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>세컨트리 인덱스</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>데이터 압축</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>인덱스 압축</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>암호화</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>In-Memory 지원</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>컬렉션 파티션</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="1-mmapv1-스토리지-엔진">1. MMAPv1 스토리지 엔진</h2>

<h2 id="2-wiredtiger-스토리지-엔진">2. WiredTiger 스토리지 엔진</h2>

<h2 id="3-메모리-스토리지-엔진">3. 메모리 스토리지 엔진</h2>

<h2 id="4-기타-스토리지-엔진">4. 기타 스토리지 엔진</h2>


  </article>

  <hr>

  <!-- <div class="question">
    <h2>Questions?</h2>
    <p>Have a question regarding the post above? <br />Or any of my designs?</p>
    

  </div> -->

  <!-- <div class="related">
    <h2>Related</h2>
    
      <li><a href="/kubernetes/ingress/" title="쿠버네티스 - 인그레스(Ingress)">쿠버네티스 - 인그레스(Ingress)
       &nbsp; <span class="post-meta">February 19, 2021</span></a>
    
      <li><a href="/kubernetes/service/" title="쿠버네티스 - 서비스(Service)">쿠버네티스 - 서비스(Service)
       &nbsp; <span class="post-meta">February 18, 2021</span></a>
    
      <li><a href="/kubernetes/deployment/" title="쿠버네티스 - 디플로이먼트(Deployment)">쿠버네티스 - 디플로이먼트(Deployment)
       &nbsp; <span class="post-meta">February 17, 2021</span></a>
    
  </div> -->

  
  
    <script src="https://utteranc.es/client.js"
      repo="youngwonseo/youngwonseo.github.io"
      issue-term="pathname"
      theme="github-light"
      crossorigin="anonymous"
      async>
    </script>
  

</div>

        </div>
        <footer class="site-footer">
<p class="small"></p>
</footer>

    </div>

    <script src="//cdn.jsdelivr.net/headroomjs/0.5.0/headroom.min.js"></script>
    <script type="text/javascript">
      var el = document.querySelector(".header-container");
      var headroom  = new Headroom(el, {
        "offset": 205,
        "tolerance": 5
      });
      headroom.init();
    </script>


    <!-- Twitter Shizzle -->
    <script type="text/javascript">
    window.twttr = (function (d, s, id) {
      var t, js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src= "https://platform.twitter.com/widgets.js";
      fjs.parentNode.insertBefore(js, fjs);
      return window.twttr || (t = { _e: [], ready: function (f) { t._e.push(f) } });
    }(document, "script", "twitter-wjs"));
    </script>

  </body>
</html>
